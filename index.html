<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>CAVE + WebXR Simulator</title>
<style>
  body { margin:0; overflow:hidden; }
  #info { position:absolute; top:0; left:0; padding:10px; background:rgba(0,0,0,0.5); color:#fff; font-family:sans-serif; }
</style>
</head>
<body>
<div id="info">
  CAVE Simulator – <b>L</b> left eye | <b>R</b> right eye | <b>S</b> toggle scene |
  <b>F</b> toggle frustum | <b>G</b> next surface | <b>Enter VR</b> button
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.139.2/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.139.2/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { DragControls } from 'three/addons/controls/DragControls.js';
import { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';
import { VRButton } from 'three/addons/webxr/VRButton.js';
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

const clock = new THREE.Clock();

/* --------------------------------------------------------------
   DisplaySurface – exactly the mathematics from the slides
   -------------------------------------------------------------- */
class DisplaySurface {
  constructor(name, origin, u, v, color) {
    this.name = name;
    this.origin = origin.clone();
    this.u = u.clone();
    this.v = v.clone();
    this.color = color;
  }

  /** view matrix (eye → surface) */
  viewMatrix(eye) {
    const n = new THREE.Vector3().crossVectors(this.u, this.v).normalize();      // normal
    const target = eye.clone().sub(n);                                          // look along -n
    const up = this.v.clone().normalize();

    const m = new THREE.Matrix4().lookAt(eye, target, up);
    // keep only rotation part (remove translation)
    m.setPosition(0,0,0);
    // translate by -eye
    const t = new THREE.Matrix4().makeTranslation(-eye.x, -eye.y, -eye.z);
    return m.multiply(t);
  }

  /** off-axis projection matrix */
  projectionMatrix(eye, zNear, zFar) {
    const uN = this.u.clone().normalize();
    const vN = this.v.clone().normalize();
    const nN = new THREE.Vector3().crossVectors(uN, vN).normalize();

    const pa = this.origin.clone();                         // lower-left
    const pb = this.origin.clone().add(this.u);             // lower-right
    const pc = this.origin.clone().add(this.v);             // upper-left

    const va = pa.clone().sub(eye);
    const vb = pb.clone().sub(eye);
    const vc = pc.clone().sub(eye);

    const d = -va.dot(nN);                                 // distance to plane

    const l = va.dot(uN) * zNear / d;
    const r = vb.dot(uN) * zNear / d;
    const b = va.dot(vN) * zNear / d;
    const t = vc.dot(vN) * zNear / d;

    return new THREE.Matrix4().makePerspective(l, r, b, t, zNear, zFar);
  }

  /** helper – draw the viewing frustum for one eye */
  frustumGroup(eye) {
    const group = new THREE.Group();

    const pa = this.origin.clone();
    const pb = this.origin.clone().add(this.u);
    const pc = this.origin.clone().add(this.v);
    const pd = this.origin.clone().add(this.u).add(this.v);

    // four triangular faces
    const verts = new Float32Array([
      eye.x,eye.y,eye.z, pa.x,pa.y,pa.z, pb.x,pb.y,pb.z,
      eye.x,eye.y,eye.z, pb.x,pb.y,pb.z, pd.x,pd.y,pd.z,
      eye.x,eye.y,eye.z, pd.x,pd.y,pd.z, pc.x,pc.y,pc.z,
      eye.x,eye.y,eye.z, pc.x,pc.y,pc.z, pa.x,pa.y,pa.z
    ]);
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(verts,3));
    geo.computeVertexNormals();
    const mat = new THREE.MeshBasicMaterial({
      color:this.color, side:THREE.DoubleSide,
      transparent:true, opacity:0.15, depthWrite:false
    });
    group.add(new THREE.Mesh(geo, mat));

    // edge lines
    const lineGeo = new THREE.BufferGeometry().setFromPoints([
      eye,pa, eye,pb, eye,pc, eye,pd
    ]);
    const lineMat = new THREE.LineBasicMaterial({color:this.color});
    group.add(new THREE.LineSegments(lineGeo, lineMat));

    return group;
  }
}

/* --------------------------------------------------------------
   Global objects
   -------------------------------------------------------------- */
let renderer, scene, camera, orbit;
let surfaces = [], surfaceTargets = [], surfaceScene;
let head, eyeL, eyeR, teapot;
let showScene = true, showFrustum = 0, curSurf = 0;
let frustumObjects = [];
let controller1, controller2, grip1, grip2;
let grabbed = null, grabController = null, grabOffset = new THREE.Vector3();

/* --------------------------------------------------------------
   Init
   -------------------------------------------------------------- */
function init() {
  // renderer
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.autoClear = false;
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(VRButton.createButton(renderer));

  // main scene (teapot)
  scene = new THREE.Scene();
  const teapotGeo = new TeapotGeometry(40,15);
  const teapotMat = new THREE.MeshPhongMaterial({color:0xffffff});
  teapot = new THREE.Mesh(teapotGeo, teapotMat);
  teapot.name = 'Teapot';
  teapot.position.set(0,0,-70);
  scene.add(teapot);
  addLights(scene);

  // head + eyes
  createHead();

  // display surfaces (exact numbers from the assignment)
  createSurfaces();

  // render-targets for the four walls
  surfaceTargets = surfaces.map(() => new THREE.WebGLRenderTarget(1024,1024));

  // visual representation of the walls
  createSurfaceScene();

  // third-person camera
  camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 10000);
  camera.position.set(100,120,300);
  orbit = new OrbitControls(camera, renderer.domElement);
  orbit.minDistance = 50;
  orbit.maxDistance = 1000;

  // mouse drag on head / teapot
  const dragObjs = [head, teapot];
  const drag = new DragControls(dragObjs, camera, renderer.domElement);
  drag.addEventListener('dragstart', e=>orbit.enabled=false);
  drag.addEventListener('dragend',   e=>orbit.enabled=true);

  // VR controllers
  setupControllers();

  // animate
  renderer.setAnimationLoop(animate);

  // UI
  window.addEventListener('resize', onResize);
  window.addEventListener('keydown', onKey);
}
init();

/* --------------------------------------------------------------
   Helpers
   -------------------------------------------------------------- */
function addLights(scn) {
  scn.add(new THREE.AmbientLight(0xffffff,0.3));
  const dir = new THREE.DirectionalLight(0xffffff,2);
  dir.position.set(200,400,300);
  dir.castShadow = true;
  scn.add(dir);
}
function createHead() {
  const IPD = 6.8;
  head = new THREE.Group();
  head.name = 'Head';
  head.position.set(50,20,50);
  scene.add(head);

  const headGeo = new THREE.SphereGeometry(10,32,16);
  const headMat = new THREE.MeshPhongMaterial({color:0xaaaaaa});
  head.add(new THREE.Mesh(headGeo, headMat));

  const eyeGeo = new THREE.SphereGeometry(3,16,16);
  eyeL = new THREE.Mesh(eyeGeo, new THREE.MeshPhongMaterial({color:0xff0000}));
  eyeL.position.set(-IPD/2,10,-6);
  head.add(eyeL);

  eyeR = new THREE.Mesh(eyeGeo, new THREE.MeshPhongMaterial({color:0x0000ff}));
  eyeR.position.set(+IPD/2,10,-6);
  head.add(eyeR);
}
function createSurfaces() {
  surfaces.push(
    new DisplaySurface('Front', new THREE.Vector3(-150,-150,-150),
                       new THREE.Vector3(300,0,0), new THREE.Vector3(0,300,0), 0x00ffff),
    new DisplaySurface('Left',  new THREE.Vector3(-150,-150, 150),
                       new THREE.Vector3(0,0,-300), new THREE.Vector3(0,300,0), 0xb9ff66),
    new DisplaySurface('Right', new THREE.Vector3( 150,-150,-150),
                       new THREE.Vector3(0,0, 300), new THREE.Vector3(0,300,0), 0xed2939),
    new DisplaySurface('Floor', new THREE.Vector3(-150,-150, 150),
                       new THREE.Vector3(300,0,0), new THREE.Vector3(0,0,-300), 0xffff00)
  );
}
function createSurfaceScene() {
  surfaceScene = new THREE.Scene();
  surfaces.forEach((s,i) => {
    const halfU = s.u.clone().multiplyScalar(0.5);
    const halfV = s.v.clone().multiplyScalar(0.5);
    const center = s.origin.clone().add(halfU).add(halfV);

    const geo = new THREE.BoxGeometry(s.u.length(), s.v.length(), 0.01);
    const mat = new THREE.MeshPhongMaterial({map:surfaceTargets[i].texture});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.copy(center);
    if (s.name==='Left')  mesh.rotation.y = Math.PI/2;
    if (s.name==='Right') mesh.rotation.y = -Math.PI/2;
    if (s.name==='Floor') { mesh.rotation.x = Math.PI/2; mesh.rotation.z = Math.PI; }
    surfaceScene.add(mesh);
  });
  addLights(surfaceScene);
}
function setupControllers() {
  const factory = new XRControllerModelFactory();
  const laser = () => {
    const g = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]);
    return new THREE.Line(g, new THREE.LineBasicMaterial({color:0xff0000}));
  };

  controller1 = renderer.xr.getController(0);
  controller1.add(laser());
  scene.add(controller1);
  grip1 = renderer.xr.getControllerGrip(0);
  grip1.add(factory.createControllerModel(grip1));
  scene.add(grip1);

  controller2 = renderer.xr.getController(1);
  controller2.add(laser());
  scene.add(controller2);
  grip2 = renderer.xr.getControllerGrip(1);
  grip2.add(factory.createControllerModel(grip2));
  scene.add(grip2);

  const grab = (c) => {
    const ray = new THREE.Raycaster();
    const mat = new THREE.Matrix4().extractRotation(c.matrixWorld);
    ray.ray.origin.setFromMatrixPosition(c.matrixWorld);
    ray.ray.direction.set(0,0,-1).applyMatrix4(mat);
    const hits = ray.intersectObject(teapot);
    if (hits.length) {
      grabbed = teapot;
      grabbed.material.emissive.set(0x00ff00);
      grabController = c;
      const cp = new THREE.Vector3().setFromMatrixPosition(c.matrixWorld);
      grabOffset.copy(teapot.position).sub(cp);
    }
  };
  const release = () => {
    if (grabbed) {
      grabbed.material.emissive.set(0x000000);
      grabbed = grabController = null;
    }
  };
  controller1.addEventListener('selectstart',()=>grab(controller1));
  controller2.addEventListener('selectstart',()=>grab(controller2));
  controller1.addEventListener('selectend',release);
  controller2.addEventListener('selectend',release);
}

/* --------------------------------------------------------------
   Animation loop
   -------------------------------------------------------------- */
function animate(time, frame) {
  // ----- VR controller grab (XR frame) -----
  if (frame && grabbed && grabController) {
    const pose = frame.getPose(grabController.targetRaySpace, renderer.xr.getReferenceSpace());
    if (pose) {
      const m = new THREE.Matrix4().fromArray(pose.transform.matrix);
      const p = new THREE.Vector3().setFromMatrixPosition(m);
      teapot.position.copy(p).add(grabOffset);
    }
  }

  // ----- sync virtual head with HMD -----
  if (frame) {
    const pose = frame.getViewerPose(renderer.xr.getReferenceSpace());
    if (pose) {
      const view = pose.views[0];
      head.position.fromArray(view.transform.position);
      head.quaternion.fromArray(view.transform.orientation);
    }
  }

  renderAll();
}

/* --------------------------------------------------------------
   Rendering (desktop + VR)
   -------------------------------------------------------------- */
function renderAll() {
  const gl = renderer.getContext();

  // 1. clear main view
  renderer.setClearColor(0x404040);
  renderer.clear();

  // 2. render the virtual world (optional)
  if (showScene) renderer.render(scene, camera);

  // 3. render each wall (left eye → red, right eye → cyan)
  surfaces.forEach((s, i) => {
    const rt = surfaceTargets[i];
    renderer.setRenderTarget(rt);
    renderer.clear();

    // left eye (red channel)
    gl.colorMask(true, false, false, false);
    const leftEye = eyeL.getWorldPosition(new THREE.Vector3());
    const leftCam = makeCam(s.viewMatrix(leftEye), s.projectionMatrix(leftEye,1,10000));
    renderer.render(scene, leftCam);

    // right eye (green+blue → cyan)
    gl.colorMask(false, true, true, false);
    const rightEye = eyeR.getWorldPosition(new THREE.Vector3());
    const rightCam = makeCam(s.viewMatrix(rightEye), s.projectionMatrix(rightEye,1,10000));
    renderer.clearDepth();
    renderer.render(scene, rightCam);

    gl.colorMask(true,true,true,true);
  });
  renderer.setRenderTarget(null);

  // 4. draw the textured walls
  renderer.render(surfaceScene, camera);

  // 5. draw head / eyes
  renderer.render(scene, camera);   // head is in the same scene as teapot

  // 6. optional frustum visualisation
  frustumObjects.forEach(o=>scene.remove(o));
  frustumObjects = [];
  if (showFrustum>0) {
    const eye = (showFrustum===1) ? eyeL.getWorldPosition(new THREE.Vector3())
                                 : eyeR.getWorldPosition(new THREE.Vector3());
    const grp = surfaces[curSurf].frustumGroup(eye);
    scene.add(grp);
    frustumObjects.push(grp);
  }
}
function makeCam(view, proj) {
  const cam = camera.clone();
  const inv = new THREE.Matrix4().copy(view).invert();
  cam.position.setFromMatrixPosition(inv);
  cam.setRotationFromMatrix(view);
  cam.projectionMatrix.copy(proj);
  return cam;
}

/* --------------------------------------------------------------
   UI
   -------------------------------------------------------------- */
function onResize() {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
}
function onKey(e) {
  switch(e.code){
    case 'KeyL': camera.position.copy(eyeL.getWorldPosition(new THREE.Vector3())); break;
    case 'KeyR': camera.position.copy(eyeR.getWorldPosition(new THREE.Vector3())); break;
    case 'KeyS': showScene = !showScene; break;
    case 'KeyF': showFrustum = (showFrustum+1)%3; break;
    case 'KeyG': if(showFrustum) curSurf = (curSurf+1)%surfaces.length; break;
  }
}
</script>
</body>
</html>