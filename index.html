<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>CAVE simulator</title>
<link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>
<div id="info">
	version 1 CAVE Simulator. The head and teapot are draggable. <br />
	"L" See from Left Eye | "R" See from Right Eye | "S" toggle show scene | "F" toggle show frustrum of each eye | "G" toggle between surfaces (Front/Left/Right/Floor)   <br />
</div>

<!-- Check: https://threejs.org/docs/index.html#manual/en/introduction/Installation 
for alternative installations -->
<script type="importmap">
    {
        "imports": {
        "three": "https://unpkg.com/three@0.139.2/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.139.2/examples/jsm/"
        }
    }
</script>


<script type ="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { DragControls } from 'three/addons/controls/DragControls.js';
    import { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

    const clock = new THREE.Clock();

class DisplaySurface 
{
    constructor(name, origin, u_vector, v_vector, color) 
    {
        this.name = name;
        this.origin = origin;
        this.u = u_vector;
        this.v = v_vector;
        this.color = color;
    }

	viewMatrix(eye)
    {
        // norm (n = u × v)
        var n = new THREE.Vector3().crossVectors(this.u, this.v).normalize();

        // target: point from in direction of -norm
        var target = new THREE.Vector3().addVectors(eye, n.clone().negate());

        // up vector
        var upVector = this.v.clone().normalize();

        var mat = new THREE.Matrix4();
        mat = mat.lookAt(eye, target, upVector); // solo rotación
        var translate = new THREE.Matrix4().makeTranslation(-eye.x, -eye.y, -eye.z);
        mat = mat.multiplyMatrices(mat, translate);

        return mat;
    }
	
    projectionMatrix(eye, znear, zfar) {
        // Normalized wall axes
        var u = this.u.clone().normalize();
        var v = this.v.clone().normalize();
        var n = new THREE.Vector3().crossVectors(u, v).normalize();

        // Vectors from eye to three corners of the wall
        var pa = this.origin.clone();            // lower-left corner (origin)
        var pb = this.origin.clone().add(this.u); // lower-right (origin + u)
        var pc = this.origin.clone().add(this.v); // upper-left  (origin + v)

        var va = pa.clone().sub(eye);
        var vb = pb.clone().sub(eye);
        var vc = pc.clone().sub(eye);

        // Distance from eye to screen (near plane)
        var d = -va.dot(n);

        // Frustum parameters at the near plane
        var left   = va.dot(u) * znear / d;
        var right  = vb.dot(u) * znear / d;
        var bottom = va.dot(v) * znear / d;
        var top    = vc.dot(v) * znear / d;

        var projMat = new THREE.Matrix4().makePerspective(left, right, top, bottom, znear, zfar);
        return projMat;
    }

    showEyeFrustrum(eye) {
        var u = this.u.clone().normalize();
        var v = this.v.clone().normalize();
        var n = new THREE.Vector3().crossVectors(u, v).normalize();

        // Vectors from eye to four corners of the wall
        var pa = this.origin.clone(); // lower-left corner (origin)
        var pb = this.origin.clone().add(this.u); // lower-right (origin + u)
        var pc = this.origin.clone().add(this.v); // upper-left  (origin + v)
        var pd = this.origin.clone().add(this.u).add(this.v); // upper-right (origin + u + v)
        
        // Create a group to hold both mesh and lines
        var group = new THREE.Group();
        
        // Create 4 triangular surfaces from eye to each edge of the screen
        var vertices = new Float32Array([
            // Triangle 1: eye -> pa -> pb
            eye.x, eye.y, eye.z,
            pa.x, pa.y, pa.z,
            pb.x, pb.y, pb.z,
            
            // Triangle 2: eye -> pb -> pd
            eye.x, eye.y, eye.z,
            pb.x, pb.y, pb.z,
            pd.x, pd.y, pd.z,
            
            // Triangle 3: eye -> pd -> pc
            eye.x, eye.y, eye.z,
            pd.x, pd.y, pd.z,
            pc.x, pc.y, pc.z,
            
            // Triangle 4: eye -> pc -> pa
            eye.x, eye.y, eye.z,
            pc.x, pc.y, pc.z,
            pa.x, pa.y, pa.z,
        ]);

        var geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geometry.computeVertexNormals();
        
        var material = new THREE.MeshBasicMaterial({
            color: this.color,
            transparent: true,
            opacity: 0.15,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        
        var mesh = new THREE.Mesh(geometry, material);
        group.add(mesh);
        
        // Add edge lines
        var linePoints = new Float32Array([
            eye.x, eye.y, eye.z,   pa.x, pa.y, pa.z,
            eye.x, eye.y, eye.z,   pb.x, pb.y, pb.z,
            eye.x, eye.y, eye.z,   pc.x, pc.y, pc.z,
            eye.x, eye.y, eye.z,   pd.x, pd.y, pd.z,
        ]);
        
        var lineGeometry = new THREE.BufferGeometry();
        lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePoints, 3));
        var lineMaterial = new THREE.LineBasicMaterial({color: this.color});
        var lines = new THREE.LineSegments(lineGeometry, lineMaterial);
        group.add(lines);

        return group;
    }
    
}


var renderer, scene, camera;
var displaySurfaces, displaySurfaceScene, displaySurfaceTargets;
var eyeCenter, eyeScene; 
var orbitControl;
var showScene = true;
var tempMatrix = new THREE.Matrix4();
var tempMatrix2 = new THREE.Matrix4();
var selectionOffset = new THREE.Matrix4();
var selectedObject = null;
var grabbingController = null;
var showEyeFrustrum = 0; // 0 = off, 1 = left eye, 2 = right eye
var frustumLines = [];
var currentSurface = 0; // 0 = front, 1 = left, 2 = right, 3 = floor
var controller1, controller2, controllerGrip1, controllerGrip2;
var locomotion = [0, 0, 0];
var dolly, dummyCam;
let raycaster;
var group;
const intersected = [];

function addDragControlToObjects()
{
    var objects = [];
    objects.push(scene.getObjectByName("Teapot"));
    objects.push(eyeScene.getObjectByName("Head"));
    
	//console.log(objects); 
	
    var controls = new DragControls( objects, camera, renderer.domElement );
    controls.addEventListener( 'hoveron', function ( event ) 
		{
            orbitControl.enabled = false;
        } );
    controls.addEventListener( 'hoveroff', function ( event ) 
	{
            orbitControl.enabled = true;
    } );
	controls.addEventListener( 'dragstart', function ( event ) 
		{
            event.object.material.emissive.set( 0xaaaaaa );
        } );
    controls.addEventListener( 'dragend', function ( event ) 
		{
            event.object.material.emissive.set( 0x000000 );
    } );
}

function createEyeScene()
{
    var IPD = 6.8; 
    eyeCenter = new THREE.Vector3(50, 20, 50);
    // eye positions relative to the head
    var eyeL = new THREE.Vector3( - IPD/2, 10, -6);
    var eyeR = new THREE.Vector3( + IPD/2, 10, -6);
    
    eyeScene = new THREE.Scene();

    // add sphere representing head
    var geometry = new THREE.SphereGeometry( 10, 32, 22 );
    var material = new THREE.MeshPhongMaterial( { color: 0xaaaaaa } );
    var head = new THREE.Mesh( geometry, material );
    head.name = "Head";
    head.position.set(eyeCenter.x, eyeCenter.y, eyeCenter.z);
    eyeScene.add(head);

    // add spheres representing L/R eyes
    var geometry = new THREE.SphereGeometry( 3, 32, 22 );
    var material = new THREE.MeshPhongMaterial( { color: 0xff0000 } );
    var sphere = new THREE.Mesh( geometry, material );
    sphere.name = "EyeL";
    sphere.position.set(eyeL.x, eyeL.y, eyeL.z);
    head.add(sphere);
	
    var geometry = new THREE.SphereGeometry( 3, 32, 22 );
    var material = new THREE.MeshPhongMaterial( { color: 0x0000ff } );
    var sphere = new THREE.Mesh( geometry, material );
    sphere.name = "EyeR";
    sphere.position.set(eyeR.x, eyeR.y, eyeR.z);
	head.add(sphere);
    
    createLights(eyeScene);
}

function createRenderer()
{
    renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true});    
    renderer.autoClear = false; // we will do manual clearing, because of the two eyes rendering
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.xr.enabled = true;
    document.body.appendChild(VRButton.createButton(renderer));
    document.body.appendChild(renderer.domElement);
}

function enableOrbitCamera(cam, renderer)
{
    orbitControl = new OrbitControls(cam, renderer.domElement );
    orbitControl.minDistance = 120;
    orbitControl.maxDistance = 50000;
}

function createLights(scn)
{
    var ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
    scn.add(ambientLight);
    var pointLight = new THREE.PointLight(0xffffff, 30, 0, 2);
    pointLight.position.set(100, 200, 200);
    pointLight.castShadow = true;
	pointLight.position.z += 200;
    scn.add(pointLight);
    var dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
    dirLight.position.set(200, 400, 300);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    dirLight.shadow.camera.near = 10;
    dirLight.shadow.camera.far = 2000;
    dirLight.shadow.radius = 2;
    scn.add(dirLight);
}

function createScene()
{
    scene = new THREE.Scene();
    group = new THREE.Group();

    var geometry = new TeapotGeometry( 40, 15);
    var material = new THREE.MeshPhongMaterial( { color: 0xffffff } );
    var teapot = new THREE.Mesh(geometry, material);
    teapot.name = "Teapot";
    teapot.position.z-=70;

    group.add( teapot );
    scene.add( group );
                
    createLights(scene);
}

// create a scene with 3D objects representing the display surfaces
function createDisplaySurfaceScene() {
    displaySurfaceScene = new THREE.Scene(); // keeps your previous desktop logic

    for (var [index, displaySurface] of displaySurfaces.entries()) {
        var origin = displaySurface.origin;
        var u = displaySurface.u;
        var v = displaySurface.v;

        var geometry = new THREE.BoxGeometry(u.length(), v.length(), 0.01);
        var material = new THREE.MeshPhongMaterial({
            map: displaySurfaceTargets[index].texture  // Use render target as wall map
        });
        var cube = new THREE.Mesh(geometry, material);
        cube.name = displaySurface.name;

        // Orient the cube
        if (displaySurface.name == "Left") cube.rotation.y = Math.PI / 2;
        if (displaySurface.name == "Right") cube.rotation.y = -Math.PI / 2;
        if (displaySurface.name == "Floor") {
            cube.rotation.x = Math.PI / 2;
            cube.rotation.z = Math.PI;
        }

        var uHalf = u.clone().multiplyScalar(0.5);
        var vHalf = v.clone().multiplyScalar(0.5);
        var center = new THREE.Vector3().addVectors(origin, uHalf);
        center.add(vHalf);
        cube.position.set(center.x, center.y, center.z);

        // ---- add to scenes ----
        displaySurfaceScene.add(cube);
        scene.add(cube); // THE KEY POINT: add every display surface mesh to your main scene for VR
    }

    createLights(displaySurfaceScene);
}



function createDisplaySurfaceTargets()
{
    const SIZE = 1024;  // texture resolution
    displaySurfaceTargets = [];
    
    for (var v of displaySurfaces)       
        displaySurfaceTargets.push(new THREE.WebGLRenderTarget(SIZE, SIZE));
}

function createCamera()
{
    camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 10000 );
    camera.position.set( 100, 100, 300 );
    camera.lookAt( 0, 0, 0 );

    dolly = new THREE.Object3D();
    dolly.position.z = 5;
    dolly.add(camera);
    scene.add(dolly);

    dummyCam = new THREE.Object3D();
    camera.add(dummyCam);
}

function createDisplaySurfaces()
{
    displaySurfaces = [];
    // FRONT SCREEN
    var frontScreen = new DisplaySurface("Front", 
        new THREE.Vector3(-150.0, -150.0, -150.0), 
        new THREE.Vector3(300.0, 0.0,   0.0), 
        new THREE.Vector3(0.0, 300.0,   0.0),
        new THREE.Color(0x00ffff));
    displaySurfaces.push(frontScreen);

    // LEFT SCREEN
    var leftScreen = new DisplaySurface("Left",
        new THREE.Vector3(-150.0, -150.0, 150.0), 
        new THREE.Vector3(0.0, 0.0,  -300.0), 
        new THREE.Vector3(0.0, 300.0,   0.0),
        new THREE.Color(0xb9ff66));
    displaySurfaces.push(leftScreen);
	
	// RIGHT SCREEN
    var rightScreen = new DisplaySurface("Right",
        new THREE.Vector3( 150.0, -150.0, -150.0),
        new THREE.Vector3(0.0, 0.0, 300.0),
        new THREE.Vector3(0.0, 300.0,   0.0),
        new THREE.Color(0xed2939));
    displaySurfaces.push(rightScreen);

    // FLOOR SCREEN
    var bottomScreen = new DisplaySurface("Floor",
        new THREE.Vector3(-150.0, -150.0, 150.0),
        new THREE.Vector3(300.0, 0.0, 0.0),
        new THREE.Vector3(0.0, 0.0, -300.0),
        new THREE.Color(0xffff00));
    displaySurfaces.push(bottomScreen);
	
}

function getLeftEyePosition()
{
    var eye = eyeScene.getObjectByName("EyeL");
    return eye.getWorldPosition(new THREE.Vector3());
}

function getRightEyePosition()
{
    var eye = eyeScene.getObjectByName("EyeR");
    return eye.getWorldPosition(new THREE.Vector3());
}

function cameraFromViewProj(view, proj)
{
	var cam = camera.clone();
    var inv = new THREE.Matrix4();
	inv.copy(view).invert();
	cam.position.set(inv.elements[12], inv.elements[13], inv.elements[14]);
	cam.setRotationFromMatrix(view);
	cam.projectionMatrix = proj.clone();
	return cam;
}

function setupControllers() {
    const controllerModelFactory = new XRControllerModelFactory();

    // Controller 1
    controller1 = renderer.xr.getController(0);
    displaySurfaceScene.add(controller1);
    controllerGrip1 = renderer.xr.getControllerGrip(0);
    controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
    displaySurfaceScene.add(controllerGrip1);
    
    // Controller 2
    controller2 = renderer.xr.getController(1);
    displaySurfaceScene.add(controller2);
    controllerGrip2 = renderer.xr.getControllerGrip(1);
    controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
    displaySurfaceScene.add(controllerGrip2);

    controller1.addEventListener('selectstart', onSelectStart);
    controller2.addEventListener('selectstart', onSelectStart);
    controller1.addEventListener('selectend', onSelectEnd);
    controller2.addEventListener('selectend', onSelectEnd);

    const geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );
    const line = new THREE.Line(geometry);
    line.name = 'line';

    controller1.add(line.clone());
    controller2.add(line.clone());

    raycaster = new THREE.Raycaster();
}

function onJoystick() {
    var handedness = "unknown";
    const session = renderer.xr.getSession();

    if (session) {
        let xrCamera = renderer.xr.getCamera(camera);

        for (const source of session.inputSources) {
            if (source && source.handedness) {
                handedness = source.handedness;
            }
            if (!source.gamepad) continue;

            const data = {
                handedness: handedness,
                buttons: source.gamepad.buttons.map((b) => b.value),
                axes: source.gamepad.axes.slice(2)
            };
            
            if (data.handedness == "left") {
                locomotion[0] = (Math.abs(data.axes[1]) > 0.4) ? data.axes[1] : 0.0;
                locomotion[2] = (Math.abs(data.axes[0]) > 0.4) ? data.axes[0] : 0.0;
            }
            else if (data.handedness == "right") {
                locomotion[1] = (Math.abs(data.axes[1]) > 0.4) ? data.axes[1] : 0.0;
            }
        }
    }
}

function characterMove(dt) {
    const session = renderer.xr.getSession();

    if (session) {
        const speed = 10;
        
        const quaternion = dolly.quaternion.clone();
        const targetQuaternion = new THREE.Quaternion();
        dolly.quaternion.copy(dummyCam.getWorldQuaternion(targetQuaternion));
        
        // Locomotion X/Z (left joystick) - relative to camera
        dolly.translateZ(locomotion[0] * dt * speed);
        dolly.translateX(locomotion[2] * dt * speed);
        
        // Restore original rotation before moving y
        dolly.quaternion.copy(quaternion);
        
        // Locomotion Y (right joystick) - absolute
        dolly.position.y += -locomotion[1] * dt * speed;
    }
}

function onSelectStart(event) {
    const controller = event.target;

    const intersections = getIntersections(controller);

    if (intersections.length > 0) {
        const intersection = intersections[0];

        const object = intersection.object;
        object.material.emissive.b = 1;

        // No reparenting: keep the object in its original scene hierarchy
        controller.updateMatrixWorld(true);
        object.updateMatrixWorld(true);

        // Save selection and relative offset so object follows controller without changing parent
        controller.userData.selected = object;
        selectedObject = object;
        grabbingController = controller;
        selectionOffset.copy(controller.matrixWorld).invert().multiply(object.matrixWorld);
        selectedObject.matrixAutoUpdate = false;
    }

    controller.userData.targetRayMode = event.data.targetRayMode;
}

function onSelectEnd(event) {
    const controller = event.target;

    if ( controller.userData.selected !== undefined ) {
        const object = controller.userData.selected;
        object.material.emissive.b = 0;
        // Ensure it remains under the main group (idempotent if already there)
        if (object.parent !== group) group.attach( object );

        controller.userData.selected = undefined;
    }

    // Restore object update behavior and clear selection state
    if (selectedObject) {
        selectedObject.matrixAutoUpdate = true;
    }
    selectedObject = null;
    grabbingController = null;
}

function getIntersections(controller) {
    controller.updateMatrixWorld();

    // Set up ray from controller
    raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    raycaster.ray.direction.set(0, 0, -1)
        .applyMatrix4(controller.matrixWorld)
        .sub(raycaster.ray.origin)
        .normalize();

    return raycaster.intersectObjects(group.children, false);
}


function intersectObjects(controller) {
    if (controller.userData.targetRayMode === 'screen') return;

    if (controller.userData.selected !== undefined) return;

    const line = controller.getObjectByName('line');
    const intersections = getIntersections(controller);

    if (intersections.length > 0) {
        const intersection = intersections[0];

        const object = intersection.object;
        object.material.emissive.r = 1;
        intersected.push( object );

        line.scale.z = intersection.distance;
    } else {
        line.scale.z = 5;
    }
}

function cleanIntersected() {
    while ( intersected.length ) {
        const object = intersected.pop();
        object.material.emissive.r = 0;
    }
}

// refresh function
var animate = function () {
    cleanIntersected();
    onJoystick();
    characterMove(clock.getDelta());

    if (renderer.xr.getSession()) {
        intersectObjects(controller1);
        intersectObjects(controller2);
    }

    var gl = renderer.getContext();
    renderer.setAnimationLoop(animate);

    // 1. render scene objects
	renderer.setClearColor(0x808080);
    renderer.clear();
    if (showScene)
        renderer.render(scene, camera);
    
    // 2. render scene objects onto a texture, for each target
    for (let [index, displaySurface] of displaySurfaces.entries())
    {
        renderer.setRenderTarget(displaySurfaceTargets[index]);
        renderer.setClearColor(0x404040);
        renderer.clear();

		// left eye on RED channel
        gl.colorMask(1, 0, 0, 0); 
		var eye = getLeftEyePosition();
		var view = displaySurface.viewMatrix(eye);
		var proj = displaySurface.projectionMatrix(eye, 1, 10000);
        var leftCamera = cameraFromViewProj(view, proj);
        renderer.render(scene, leftCamera); 
    
		// right eye on GREEN, BLUE channels
		gl.colorMask(0, 1, 1, 0);
		var eye = getRightEyePosition();
		var view = displaySurface.viewMatrix(eye);
		var proj = displaySurface.projectionMatrix(eye, 1, 10000);
        var rightCamera = cameraFromViewProj(view, proj);
        renderer.clearDepth();
        renderer.render(scene, rightCamera); 
		
        gl.colorMask(1, 1, 1, 0);
    }
    // restore state
    renderer.setRenderTarget(null);
    renderer.setClearColor(0x000000);
  
    // 3. render display surfaces as (textured) quads
    renderer.render(displaySurfaceScene, camera);
	
	// 4. render eyes
    renderer.render(eyeScene, camera);

    // 5. Update frustum lines if enabled
    if (showEyeFrustrum > 0) {
        // Remove old lines
        for (var line of frustumLines) {
            eyeScene.remove(line);
        }
        frustumLines = [];
        
        // Determine which eye to use: 1 = left, 2 = right
        var eye = (showEyeFrustrum == 1) ? getLeftEyePosition() : getRightEyePosition();
        
        // Show only the selected surface
        var lines = displaySurfaces[currentSurface].showEyeFrustrum(eye);
        eyeScene.add(lines);
        frustumLines.push(lines);
    } else {
        // Remove all lines
        for (var line of frustumLines) {
            eyeScene.remove(line);
        }
        frustumLines = [];
    }

    if (selectedObject && grabbingController) {
        // Follow controller without changing the object's parent/scene
        // world = controllerWorld * selectionOffset
        const world = tempMatrix2.multiplyMatrices(grabbingController.matrixWorld, selectionOffset);
        // local = parentInv * world
        const parentInv = tempMatrix.copy(selectedObject.parent.matrixWorld).invert();
        const local = world.clone().premultiply(parentInv);

        selectedObject.matrix.copy(local);
        selectedObject.matrix.decompose(selectedObject.position, selectedObject.quaternion, selectedObject.scale);
    }
	
};


window.addEventListener( 'keydown', function ( event ) 
{
    switch ( event.code ) {
        case 'KeyF':
            showScene = true;
            showEyeFrustrum = (showEyeFrustrum + 1)%3;
            break;

        case 'KeyG':
            showScene = true;
            if (showEyeFrustrum > 0) currentSurface = (currentSurface + 1) % displaySurfaces.length;
            break;

        case 'KeyL': 
            var eye = getLeftEyePosition();
            camera.position.set(eye.x, eye.y, eye.z); 
            showEyeFrustrum = 0;
            currentSurface = 0;
            break;
            
        case 'KeyR': 
            var eye = getRightEyePosition();
            camera.position.set(eye.x, eye.y, eye.z); 
            showEyeFrustrum = 0;
            currentSurface = 0;
            break;
            
        case 'KeyS':
            showScene = !showScene;
            if (!showScene) {
                showEyeFrustrum = 0;
                currentSurface = 0;
            }
            break;
            
        case 'KeyT':
            var viewF = displaySurfaces[0].viewMatrix(new THREE.Vector3(50,20,100));
            var viewL = displaySurfaces[1].viewMatrix(new THREE.Vector3(50,20,100));
            var viewR = displaySurfaces[2].viewMatrix(new THREE.Vector3(50,20,100));
            var viewB = displaySurfaces[3].viewMatrix(new THREE.Vector3(50,20,100));
            console.log("View matrices:");
            console.log(viewF);
            console.log(viewL);
            console.log(viewR);
            console.log(viewB);

            var projF = displaySurfaces[0].projectionMatrix(new THREE.Vector3(50, 20, 100), 0.1, 100);
            var projL = displaySurfaces[1].projectionMatrix(new THREE.Vector3(50, 20, 100), 0.1, 100);
            var projR = displaySurfaces[2].projectionMatrix(new THREE.Vector3(50, 20, 100), 0.1, 100);
            var projB = displaySurfaces[3].projectionMatrix(new THREE.Vector3(50, 20, 100), 0.1, 100);
            console.log("Projection matrices:");
            console.log(projF);
            console.log(projL);
            console.log(projR);
            console.log(projB);

            break;
        
        case 'ArrowLeft':
            characterMove();
            break;

        case 'ArrowUp':
            console.log("UP");
            break;

        case 'ArrowDown':
            console.log("DOWN");
            break;

        case 'ArrowRight':
            console.log("RIGHT");
            break;                         
    }
});



createRenderer();
createDisplaySurfaces();
createDisplaySurfaceTargets();
createScene();            // CREATES 'scene' AND 'group'
createDisplaySurfaceScene();  // MUST RUN AFTER createScene()
createEyeScene();
setupControllers();
createCamera();
enableOrbitCamera(camera, renderer);
addDragControlToObjects();
animate();


		</script>
    </body>
</html>
